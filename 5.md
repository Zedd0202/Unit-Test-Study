# Chapter 5. 좋은 테스트의 FIRST속성. 

### 좋은 테스트 조건.
- FIRST원리...를 따르면 단위테스트 작성자가 흔히 빠지는 위험을 피할 수 있음.
1. Fast 빠른
2. Isolated 고립된
3. Repeatable 반복 가능한
4. Self-validating 스스로 검증 가능한
5. Timely 적시의


### Fast. 
- 빠른테스트 -> 코드만 실행.
- 느린테스트 -> DB, file, 네트워크 호출처럼 외부 자원을 다루는 코드 호출.

단위테스트 전체를 수행하는데 오래걸린다면 무언가 잘못된 방향으로 가고있는것임. 단위테스트는 지속적이고 **빠른** 피드백으 주지 못하면 그만크 저하됨.
그니까 테스트르 빠르게 유지하셈!! 설계를 깨끗하게 하면^^..빠르게 유지 가능.

가장 먼저 느린 테스트에 대한 의존성 줄이기.
- 느린것에 의존하는 코드를 최소화 한다면, 작성하기도 쉬워짐
- 이러한 의존성으 최소화하는 것 역시 좋은 설계의 목표.


### Isolated

좋은 단위 테스트? 
- 검증하려는 작은 양의 코드에 집중. (하지만 직/간접 적으로 테스트코드와 상호작용하는 코드가 많을수록 문제가 발생할 소지가 늘어난다.)
- 다른 단위 테스트에 의존하지 않는다. (테스트 코드는 어떤 순서나 시간에 관계없이 실행 할 수 있어야함)
- 테스트가 하나 이상의 이유로 깨진다면, 테스트를 분할하는 것도 고려.

### Repeatable: 좋은 테스트는 반복 가능해야한다.

- 테스트는 실행 할 때마다 결과가 같아야함. -> 그럴려면 직접 통제할 수 없느 외부 환경에 있는 항목들과 격리시켜야함. 
- 하지만 불가피하게 통제할 수 없는 요소와 상호작용 해야할 것.(ex, 시간, DB) (이때 mock객체 사용?) 


### Self-validating

- 테스트 결과를 수동으로 검증하는 것은 시간소모적인 절차. 리스트 높아짐. -> 테스트느 스스로 검증 가능할 뿐만 아니라 준비할 수도 있어야 한다. 
- 테스트에 필요한 어떤 설정 단계든 자동화해야함. 그럼에도 외부 설정이 필요하다면 Isolated를 위반한거임

# Timely

- 가능하면 적절한 순간에 단위테스트에 집중하는게 좋다.
- 단위테스트를 더 많이할 수록 테스트 대상 코드가 줄어듬. 
-> 단위테스트 작성이 쉬워짐. 새로운 코드를 넣었을 때 효과 즉시 나타남.

- 옛날 코드에 대한 테스트는 시간 낭비가 될 수 있음. 코드에 큰 결함이 없고 당장 변경할 예정이 없다면 굳이 ㄴㄴ.










