# Chapter 4. 테스트 조직.

### AAA로 테스트 일관서 유지
- 트리플 A. Arrange, Act, Assert.

- Arrange
> 테스트코드를 실행하기 전에 시스템이 적절한 상태에 있는지 확인. 객체를 생성하거나 다른 API호출. 생략가능.

- Act
> 테스트코드를 실행.

- Assert
> 실행한 코드가 기대한 대로 동작하는지 확인. 

때에따라 4번째 단계인 After가 존재. 
- After
> 테스트를 실행 할 때 어떤 자원을 할당했다면 잘 정리되었는지 확인해야함. 


### 동작 테스트 vs 메소드 테스트
- 테스트를 작성할 때는 **클래스의 동작에 집중**해야하며, 개별 메소드를 테스트 한다고 생각하면 안됨!!!!!!!!!!!!!
- 단위테스트를 작성할 때는 먼저 전체적인 시각에서 시작해야함. ex) 출금 테스트르 위해 먼저 입금 할 필요가 있음.
- 개별 메소드를 테스트 하는것이 아니라, 클래스의 종합적인 동작을 테스트 해야한다. 

### 테스트와 프로덕션 코드의 관계
- 테스트는 주어진 프로젝트 안에서 프로덕션 코드와 분리해아함.
- 단위테스트는 프로그래머만 하는 활동임! 고객이나 최종 사용자, 비프로그래머는 테스트 결과를 보거나 실행만 해야한다.
- **테스트 코드는 프로덕션 시스템 코드를 의존하지만, 그 반대는 해당 x. 프로덕션 코드는 테스트코드의 존재를 모른다**
- 하지마 테스트를 작성하는 행위가 프로덕션 시스템의 설계에 영향을 주지 않는다는건 아님

### 내부 데이터 노출 vs 내부 동작 노출
- 어떤 개발자들은 테스트를 작성할 떄, 프로덕션 코드의 public 인터페이스만 사용해야한다고 믿음. public이 아닌 메소드를 테스트 코드에서 호출하면 정보 은닉원칙을 위배한다고 생각.
- 비공개 코드를 호출하는 테스트는 그 자체로 구현 세부 사항과 결속하게 된다. 이러한 구현 세부사항이 변경되면 테스트는 깨질 수 있음. 
- 이렇게 내부의 구현 세부사항을 테스트 하는것은 저품질로 이어질 수 있다. why? 테스트 코드가 과도하게 내부 구현 세부사항을 아는 상태 -> 코드의 작은 변화가 일어남 
-> 테스트 깨짐 -> 테스트가 많이 깨질 수록 프로그래머는 리팩토링 꺼려함. -> 리팩토링이 줄어들수록 코드베이스는 빠르게 퇴화.

**테스트를 위해 내부 데이터를 노출하는 것은 테스트와 프로덕션 코드 사이에 과도한 결합을 초래**
커다란 클래스는 종종 private메소드 포함하고 있음 -> 이 테스트들을 테스트 하고싶어!! 하는 충동 -> 그럼 설계에 문제가 있는거임ㅎ -> SRP(클래스는 작고 단일 목적을 가져아함을 의미)를 어겼을 확률이 높다.
- 가장 좋은 해결책은 그 충동을 느끼는...private메소드를 추출하여 다른 클래스로 이동하는 것! 그렇게 하면 그 private메소드는 옮긴 클래스의 유용한 public클래스가 된다. 

### 테스트의 가치. 
다수의 케이스르 별로드이 테스트로 분리하셈.

- 테스트 실패했을 때 빠르게 파악 가능.
- 실패한 테스트르 해독하는데 필요한 시간을 줄일 수 있음.
- 모든 케이스가 실행되었음을 보장할 수 있음.

### 테스트 문서화.

- 일관성 있는 이름으로 테스트 문서화.
> 테스트하려느 맥락을 제안하기 보다는 어떤 맥락에서 일련의 행동을 호출했으 때, 어떤 결과가 나오는지를 명시
> 합리적인 이름은 단어 일곱개 정도로 구성....??<p>
> doingSomeOperationGenerateSomeResult, someResultOccursUnderSomeCondition..

어떤 형식이든 일관성을 유지하는 것이 중요. 주요 목표는 테스트 코드를 다른 사람에게 의미 있게 만드는 것.

- 테스트를 의미있게 만들기
> 테스트 이름, 지역변수 이름 개선, 의미있는 상수 도입, 햄크레스트 assert사용....등등

### @Before와 @After
- @Before메소드는 매번 테스트 메소드 실행에 앞서 실행. 모든 테스트에 적용되며, 그 클래스에 있는 모든 테스트에 앞서 실행되어야 하는 코드만 넣기!
> 주의 : 다수의 @Before메소드가 있을 때, JUnit은 어떤 실해 순서를 보장하지 않음. 

- @After메소드는 각 테스트를 실행 한 후에 실행되며 **테스트가 실패**하더라도 실행됨. 테스트에 발생하는 부산물들을 정리하는 역할을 한다.

### 녹색이 좋다. 테스트를 의미있게 유지.
- 대부분의 단위테스트는 매우 빨라야함. 견딜 수 있을 만큼의 테스트를 실행 할 것. 

### 테스트 제외
- 다수의 테스트 실패를 다루는 한가지 방법은 문제가 있느 테스트에 집중하고, 다른 실패 테스트는 주석 처리 하는 것. 주석처리보다 @ignore annotation을 달면 된다.












